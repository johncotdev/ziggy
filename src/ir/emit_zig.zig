//! Zibol IR to Zig Code Emitter
//!
//! Generates Zig source code from IR, with special handling for:
//! - C ABI exports for .NET P/Invoke interop
//! - Zibol type marshaling (alpha, decimal, etc.)
//! - Record structure generation
//!
//! The emitted code can be compiled by the Zig compiler to produce
//! native shared libraries callable from .NET.

const std = @import("std");
const ir = @import("ir.zig");

const Allocator = std.mem.Allocator;

pub const EmitError = error{
    OutOfMemory,
    WriteError,
};

/// Zig code emitter from IR
pub const ZigEmitter = struct {
    allocator: Allocator,
    output: std.ArrayList(u8),
    indent_level: u32,

    const Self = @This();

    pub fn init(allocator: Allocator) Self {
        return .{
            .allocator = allocator,
            .output = std.ArrayList(u8).init(allocator),
            .indent_level = 0,
        };
    }

    pub fn deinit(self: *Self) void {
        self.output.deinit();
    }

    /// Emit a complete IR module to Zig source
    pub fn emitModule(self: *Self, module: *const ir.Module) EmitError![]const u8 {
        // File header
        try self.write("//! Generated by Ziggy Zibol Compiler\n");
        try self.write("//! Module: ");
        try self.write(module.name);
        try self.write("\n\n");

        // Standard imports
        try self.write("const std = @import(\"std\");\n");
        try self.write("const runtime = @import(\"../runtime/runtime.zig\");\n");
        try self.write("\n");

        // Emit record types as Zig structs
        for (module.records.items) |rec| {
            try self.emitRecordType(rec);
            try self.write("\n");
        }

        // Emit global variables
        for (module.globals.items) |global| {
            try self.emitGlobal(&global);
        }
        if (module.globals.items.len > 0) {
            try self.write("\n");
        }

        // Emit functions
        for (module.functions.items) |func| {
            try self.emitFunction(func);
            try self.write("\n");
        }

        return self.output.toOwnedSlice() catch return EmitError.OutOfMemory;
    }

    /// Emit a record type as a Zig packed struct
    fn emitRecordType(self: *Self, rec: *const ir.RecordType) EmitError!void {
        try self.write("/// Record: ");
        try self.write(rec.name);
        try self.write("\n");
        try self.write("pub const ");
        try self.write(rec.name);
        try self.write(" = extern struct {\n");

        self.indent_level += 1;
        for (rec.fields) |field| {
            try self.writeIndent();
            try self.write(field.name);
            try self.write(": ");
            try self.emitType(field.ty);
            try self.write(",\n");
        }
        self.indent_level -= 1;

        try self.write("};\n");
    }

    /// Emit a global variable declaration
    fn emitGlobal(self: *Self, global: *const ir.Module.Global) EmitError!void {
        try self.write("var ");
        try self.write(global.name);
        try self.write(": ");
        try self.emitType(global.ty);
        if (global.initializer) |init_val| {
            try self.write(" = ");
            try self.write(init_val);
        } else {
            try self.write(" = undefined");
        }
        try self.write(";\n");
    }

    /// Emit a function
    fn emitFunction(self: *Self, func: *const ir.Function) EmitError!void {
        // Documentation comment
        try self.write("/// Function: ");
        try self.write(func.name);
        try self.write("\n");

        // Export attribute for C ABI functions
        if (func.linkage == .export_c) {
            try self.write("pub export fn ");
            if (func.export_name) |exp_name| {
                try self.write(exp_name);
            } else {
                try self.write(func.name);
            }
        } else {
            try self.write("fn ");
            try self.write(func.name);
        }

        // Parameters
        try self.write("(");
        for (func.signature.params, 0..) |param, i| {
            if (i > 0) try self.write(", ");

            try self.write(param.name);
            try self.write(": ");

            // For C ABI exports, use C-compatible types
            if (func.linkage == .export_c) {
                try self.emitCAbiType(param.ty);
            } else {
                try self.emitType(param.ty);
            }
        }

        // Calling convention for C exports
        if (func.linkage == .export_c) {
            try self.write(") callconv(.C) ");
        } else {
            try self.write(") ");
        }

        // Return type
        if (func.linkage == .export_c) {
            try self.emitCAbiType(func.signature.return_type);
        } else {
            try self.emitType(func.signature.return_type);
        }

        try self.write(" {\n");

        // Function body - emit blocks
        self.indent_level += 1;
        for (func.blocks.items) |block| {
            try self.emitBlock(block);
        }
        self.indent_level -= 1;

        try self.write("}\n");
    }

    /// Emit a basic block
    fn emitBlock(self: *Self, block: *const ir.Block) EmitError!void {
        // Block label (as a comment for now, could become Zig labeled blocks)
        if (!std.mem.eql(u8, block.label, "entry")) {
            try self.writeIndent();
            try self.write("// ");
            try self.write(block.label);
            try self.write(":\n");
        }

        for (block.instructions.items) |inst| {
            try self.emitInstruction(&inst);
        }
    }

    /// Emit an instruction
    fn emitInstruction(self: *Self, inst: *const ir.Instruction) EmitError!void {
        try self.writeIndent();

        switch (inst.*) {
            .alloca => |a| {
                try self.write("var ");
                try self.write(a.name);
                try self.write(": ");
                try self.emitType(a.ty);
                try self.write(" = undefined; // %");
                try self.writeInt(a.result.id);
                try self.write("\n");
            },
            .load => |l| {
                try self.write("const _v");
                try self.writeInt(l.result.id);
                try self.write(" = ");
                try self.writeValue(l.ptr);
                try self.write(";\n");
            },
            .store => |s| {
                try self.writeValue(s.ptr);
                try self.write(" = ");
                try self.writeValue(s.value);
                try self.write(";\n");
            },
            .add => |op| try self.emitBinaryOp("+", &op),
            .sub => |op| try self.emitBinaryOp("-", &op),
            .mul => |op| try self.emitBinaryOp("*", &op),
            .div => |op| try self.emitBinaryOp("/", &op),
            .mod => |op| try self.emitBinaryOp("%", &op),
            .cmp_eq => |op| try self.emitBinaryOp("==", &op),
            .cmp_ne => |op| try self.emitBinaryOp("!=", &op),
            .cmp_lt => |op| try self.emitBinaryOp("<", &op),
            .cmp_le => |op| try self.emitBinaryOp("<=", &op),
            .cmp_gt => |op| try self.emitBinaryOp(">", &op),
            .cmp_ge => |op| try self.emitBinaryOp(">=", &op),
            .log_and => |op| try self.emitBinaryOp("and", &op),
            .log_or => |op| try self.emitBinaryOp("or", &op),
            .neg => |op| {
                try self.write("const _v");
                try self.writeInt(op.result.id);
                try self.write(" = -");
                try self.writeValue(op.operand);
                try self.write(";\n");
            },
            .log_not => |op| {
                try self.write("const _v");
                try self.writeInt(op.result.id);
                try self.write(" = !");
                try self.writeValue(op.operand);
                try self.write(";\n");
            },
            .ret => |v| {
                try self.write("return");
                if (v) |val| {
                    try self.write(" ");
                    try self.writeValue(val);
                }
                try self.write(";\n");
            },
            .br => |b| {
                try self.write("// goto ");
                try self.write(b.target.label);
                try self.write("\n");
            },
            .cond_br => |c| {
                try self.write("if (");
                try self.writeValue(c.condition);
                try self.write(") {\n");
                self.indent_level += 1;
                try self.writeIndent();
                try self.write("// then: ");
                try self.write(c.then_block.label);
                try self.write("\n");
                self.indent_level -= 1;
                try self.writeIndent();
                try self.write("} else {\n");
                self.indent_level += 1;
                try self.writeIndent();
                try self.write("// else: ");
                try self.write(c.else_block.label);
                try self.write("\n");
                self.indent_level -= 1;
                try self.writeIndent();
                try self.write("}\n");
            },
            .call => |c| {
                if (c.result) |r| {
                    try self.write("const _v");
                    try self.writeInt(r.id);
                    try self.write(" = ");
                }
                try self.write(c.callee);
                try self.write("(");
                for (c.args, 0..) |arg, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeValue(arg);
                }
                try self.write(");\n");
            },
            .xcall => |x| {
                try self.write("runtime.xcall(\"");
                try self.write(x.routine);
                try self.write("\", .{");
                for (x.args, 0..) |arg, i| {
                    if (i > 0) try self.write(", ");
                    try self.writeValue(arg);
                }
                try self.write("});\n");
            },
            .const_int => |c| {
                try self.write("const _const = ");
                try self.writeInt64(c.value);
                try self.write(";\n");
            },
            .const_alpha => |c| {
                try self.write("const _const = \"");
                try self.write(c.value);
                try self.write("\";\n");
            },
            .const_decimal => |c| {
                try self.write("const _const = ");
                try self.writeInt64(c.value);
                try self.write("; // decimal\n");
            },
            .io_open => |o| {
                try self.write("runtime.openChannel(");
                try self.writeValue(o.channel);
                try self.write(", \"");
                try self.write(o.mode);
                try self.write("\", ");
                try self.writeValue(o.filename);
                try self.write(");\n");
            },
            .io_close => |c| {
                try self.write("runtime.closeChannel(");
                try self.writeValue(c.channel);
                try self.write(");\n");
            },
            .io_read => |r| {
                try self.write("runtime.readChannel(");
                try self.writeValue(r.channel);
                try self.write(", &");
                try self.writeValue(r.record);
                if (r.key) |k| {
                    try self.write(", ");
                    try self.writeValue(k);
                }
                try self.write(");\n");
            },
            .io_write => |w| {
                try self.write("runtime.writeChannel(");
                try self.writeValue(w.channel);
                try self.write(", &");
                try self.writeValue(w.record);
                try self.write(");\n");
            },
            .io_display => |d| {
                try self.write("runtime.display(");
                try self.writeValue(d.channel);
                for (d.values) |v| {
                    try self.write(", ");
                    try self.writeValue(v);
                }
                try self.write(");\n");
            },
            else => {
                try self.write("// TODO: unimplemented instruction\n");
            },
        }
    }

    /// Emit a binary operation
    fn emitBinaryOp(self: *Self, op: []const u8, bin: *const ir.Instruction.BinaryOp) EmitError!void {
        try self.write("const _v");
        try self.writeInt(bin.result.id);
        try self.write(" = ");
        try self.writeValue(bin.lhs);
        try self.write(" ");
        try self.write(op);
        try self.write(" ");
        try self.writeValue(bin.rhs);
        try self.write(";\n");
    }

    /// Emit a Zig type from IR type
    fn emitType(self: *Self, ty: ir.Type) EmitError!void {
        switch (ty) {
            .void => try self.write("void"),
            .alpha => |len| {
                try self.write("[");
                try self.writeInt(len);
                try self.write("]u8");
            },
            .decimal => |d| {
                // Use i64 for decimals, tracking precision separately
                _ = d;
                try self.write("i64");
            },
            .integer => |size| {
                switch (size) {
                    1 => try self.write("i8"),
                    2 => try self.write("i16"),
                    4 => try self.write("i32"),
                    8 => try self.write("i64"),
                    else => try self.write("i64"),
                }
            },
            .packed_decimal => try self.write("i64"),
            .ptr => |inner| {
                try self.write("*");
                try self.emitType(inner.*);
            },
            .array => |a| {
                try self.write("[");
                try self.writeInt(a.length);
                try self.write("]");
                try self.emitType(a.element.*);
            },
            .record => |r| try self.write(r.name),
            .function => try self.write("*const fn() void"),
        }
    }

    /// Emit C ABI compatible type
    fn emitCAbiType(self: *Self, ty: ir.Type) EmitError!void {
        switch (ty) {
            .void => try self.write("void"),
            .alpha => try self.write("[*]u8"), // Pointer for C strings
            .decimal => try self.write("i64"),
            .integer => |size| {
                switch (size) {
                    1 => try self.write("i8"),
                    2 => try self.write("i16"),
                    4 => try self.write("i32"),
                    8 => try self.write("i64"),
                    else => try self.write("i64"),
                }
            },
            .packed_decimal => try self.write("i64"),
            .ptr => try self.write("?*anyopaque"),
            .array => try self.write("?*anyopaque"),
            .record => try self.write("?*anyopaque"),
            .function => try self.write("?*const fn() callconv(.C) void"),
        }
    }

    /// Write a value reference
    fn writeValue(self: *Self, value: ir.Value) EmitError!void {
        try self.write("_v");
        try self.writeInt(value.id);
    }

    /// Write an integer
    fn writeInt(self: *Self, val: u32) EmitError!void {
        var buf: [16]u8 = undefined;
        const slice = std.fmt.bufPrint(&buf, "{d}", .{val}) catch return EmitError.WriteError;
        try self.write(slice);
    }

    /// Write an i64
    fn writeInt64(self: *Self, val: i64) EmitError!void {
        var buf: [24]u8 = undefined;
        const slice = std.fmt.bufPrint(&buf, "{d}", .{val}) catch return EmitError.WriteError;
        try self.write(slice);
    }

    /// Write indentation
    fn writeIndent(self: *Self) EmitError!void {
        var i: u32 = 0;
        while (i < self.indent_level) : (i += 1) {
            try self.write("    ");
        }
    }

    /// Write a string to output
    fn write(self: *Self, s: []const u8) EmitError!void {
        self.output.appendSlice(s) catch return EmitError.OutOfMemory;
    }
};

// ============================================================================
// C Header Generator
// ============================================================================

/// Generate a C header file for the exported functions
pub fn generateCHeader(allocator: Allocator, module: *const ir.Module) ![]const u8 {
    var output = std.ArrayList(u8).init(allocator);
    errdefer output.deinit();

    const writer = output.writer();

    // Header guard
    try writer.print("// Generated C header for {s}\n", .{module.name});
    try writer.writeAll("#ifndef ZIGGY_");
    try writer.writeAll(module.name);
    try writer.writeAll("_H\n#define ZIGGY_");
    try writer.writeAll(module.name);
    try writer.writeAll("_H\n\n");

    try writer.writeAll("#include <stdint.h>\n\n");

    try writer.writeAll("#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");

    // Emit exported functions
    for (module.functions.items) |func| {
        if (func.linkage != .export_c) continue;

        const name = func.export_name orelse func.name;

        // C return type
        try writer.writeAll(func.signature.return_type.cTypeName());
        try writer.writeAll(" ");
        try writer.writeAll(name);
        try writer.writeAll("(");

        // Parameters
        for (func.signature.params, 0..) |param, i| {
            if (i > 0) try writer.writeAll(", ");
            try writer.writeAll(param.ty.cTypeName());
            try writer.writeAll(" ");
            try writer.writeAll(param.name);
        }

        try writer.writeAll(");\n");
    }

    try writer.writeAll("\n#ifdef __cplusplus\n}\n#endif\n\n");
    try writer.writeAll("#endif\n");

    return output.toOwnedSlice();
}

// ============================================================================
// Tests
// ============================================================================

test "emit simple function" {
    const allocator = std.testing.allocator;

    // Create a simple function
    const sig = ir.FunctionType{
        .params = &[_]ir.FunctionType.Param{
            .{ .name = "x", .ty = .{ .decimal = .{ .length = 8, .decimal_places = 2 } }, .direction = .in },
            .{ .name = "y", .ty = .{ .decimal = .{ .length = 8, .decimal_places = 2 } }, .direction = .in },
        },
        .return_type = .{ .decimal = .{ .length = 10, .decimal_places = 2 } },
        .is_variadic = false,
    };

    const func = try ir.Function.init(allocator, "add_values", sig);
    defer func.deinit();

    func.setExport("ziggy_add_values");

    // Create module
    var module = ir.Module.init(allocator, "test_module");
    defer module.deinit();

    try module.functions.append(allocator, func);
    _ = module.functions.pop(); // Don't let module free it

    // Emit
    var emitter = ZigEmitter.init(allocator);
    defer emitter.deinit();

    const output = try emitter.emitModule(&module);
    defer allocator.free(output);

    // Verify output contains expected elements
    try std.testing.expect(std.mem.indexOf(u8, output, "export fn") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "ziggy_add_values") != null);
    try std.testing.expect(std.mem.indexOf(u8, output, "callconv(.C)") != null);
}

test "generate c header" {
    const allocator = std.testing.allocator;

    const sig = ir.FunctionType{
        .params = &[_]ir.FunctionType.Param{
            .{ .name = "amount", .ty = .{ .decimal = .{ .length = 8, .decimal_places = 2 } }, .direction = .in },
        },
        .return_type = .{ .decimal = .{ .length = 10, .decimal_places = 2 } },
        .is_variadic = false,
    };

    const func = try ir.Function.init(allocator, "calculate", sig);
    defer func.deinit();

    func.setExport("ziggy_calculate");

    var module = ir.Module.init(allocator, "pricing");
    defer module.deinit();

    try module.functions.append(allocator, func);
    _ = module.functions.pop();

    const header = try generateCHeader(allocator, &module);
    defer allocator.free(header);

    try std.testing.expect(std.mem.indexOf(u8, header, "int64_t ziggy_calculate") != null);
    try std.testing.expect(std.mem.indexOf(u8, header, "int64_t amount") != null);
}
